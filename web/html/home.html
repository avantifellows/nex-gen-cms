<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Avanti Next Generation CMS</title>
    <script src="https://unpkg.com/htmx.org@2.0.4"></script>
    <!-- For tailwind css library -->
    <link href="/web/static/css/output.css" rel="stylesheet">
    <!-- For Font Awesome library -->
    <script src="https://kit.fontawesome.com/76cfc651ea.js" crossorigin="anonymous"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>
    <script src="/web/static/js/constants.js"></script>
    <script>
        function afterDropdownReq(dropdown, selectedValue) {
            /* 
             * execute code inside setTimeout(); otherwise playwright test related to onLoaded event trigger 
             * fails on firefox & webkit sometimes, because 'onLoaded' gets triggered even before setting 
             * listener for this event to verify
             */
            setTimeout(function () {
                htmx.trigger('#' + dropdown.id, 'onLoaded');
            }, 0);

            // update dropdown value to last selected value from session storage
            var sessionStorageKey;
            switch (dropdown.id) {
                case 'curriculum-dropdown':
                    sessionStorageKey = 'selectedCurriculum';
                    break;

                case 'grade-dropdown':
                    sessionStorageKey = 'selectedGrade';
                    break;

                case 'subject-dropdown':
                    sessionStorageKey = 'selectedSubject';
                    break;

                default:
                    break;
            }
            if (!selectedValue) {
                // if dropdown selection is not known from url then get it from sessionStorage
                selectedValue = sessionStorage.getItem(sessionStorageKey);
            }
            if (selectedValue) {
                dropdown.value = selectedValue;
            }
        }
    </script>
</head>

<body hx-ext="mathJaxLoader">
    <div>
        <nav>
            <div class="nav nav-tabs" id="nav-tab">
                <button class="nav-link" id="chapters-tab" hx-get="/chapters" hx-push-url="/chapters" hx-target="body"
                    data-toggle="tab"
                    hx-on::before-request="sessionStorage.setItem(window.CHAPTERS_LOADED_KEY, 'false')">Chapters</button>
                <button class="nav-link" id="modules-tab" hx-get="/modules" hx-push-url="/modules" hx-target="body"
                    data-toggle="tab">Modules</button>
                <button class="nav-link" id="books-tab" hx-get="/books" hx-push-url="/books" hx-target="body"
                    data-toggle="tab">Books</button>
                <button class="nav-link" id="tests-tab" hx-get="/tests" hx-push-url="/tests" hx-target="body"
                    data-toggle="tab"
                    hx-on::before-request="sessionStorage.setItem(window.TESTS_LOADED_KEY, 'false')">Tests</button>

                <!-- name attribute is used, because query parameters passed via http request can be 
                 identified by element names only. It is used in chapter_handler.go -->
                <select class="ms-8" id="curriculum-dropdown" name="curriculum-dropdown" hx-get="/api/curriculums"
                    hx-trigger="load" hx-on::after-request="afterDropdownReq(this, 
                    {{ if .CurriculumID }}{{ .CurriculumID }}{{ else }}null{{ end }})"
                    onchange="sessionStorage.setItem('selectedCurriculum', this.value); sessionStorage.setItem(window.CHAPTERS_LOADED_KEY, 'false'); sessionStorage.setItem(window.TESTS_LOADED_KEY, 'false');">
                    <!-- HTMX will replace this with the new options -->
                    <option disabled selected>Loading curriculums...</option>
                </select>
                <select class="ms-4" id="grade-dropdown" name="grade-dropdown" hx-get="/api/grades" hx-trigger="load"
                    hx-on::after-request="afterDropdownReq(this, 
                    {{ if .GradeID }}{{ .GradeID }}{{ else }}null{{ end }})"
                    onchange="sessionStorage.setItem('selectedGrade', this.value); sessionStorage.setItem(window.CHAPTERS_LOADED_KEY, 'false'); sessionStorage.setItem(window.TESTS_LOADED_KEY, 'false');">
                    <!-- HTMX will replace this with the new options -->
                    <option disabled selected>Loading grades...</option>
                </select>
                <select class="ms-4" id="subject-dropdown" name="subject-dropdown" hx-get="/api/subjects"
                    hx-trigger="load"
                    hx-on::after-request="afterDropdownReq(this, {{ if .SubjectID }}{{ .SubjectID }}{{ else }}null{{ end }})"
                    onchange="sessionStorage.setItem('selectedSubject', this.value); sessionStorage.setItem(window.CHAPTERS_LOADED_KEY, 'false');">
                    <!-- HTMX will replace this with the new options -->
                    <option disabled selected>Loading subjects...</option>
                </select>
            </div>
        </nav>

        <div class="m-7" id="nav-tabContent">
            <div id="content">
                {{ block "content" . }}<p>Select a tab to load content.</p>{{ end }}
            </div>
        </div>
    </div>

    <!-- Modules (type="module") are scoped, meaning functions are not global by default.
     Direct imports work only inside module scripts. Need to attach such functions to window if we need them 
     in non-module scripts. Otherwise we need to convert all scripts to module type and import 
     it wherever we want to use isInt() and then any function defined inside such module script cannot be 
     accessed from same file's html code -->
    <script type="module">
        import { isInt } from '/web/static/js/utils.js';

        // Attach to window to make it globally accessible
        window.isInt = isInt;
    </script>
    <script>

        document.addEventListener("DOMContentLoaded", function () {
            let lastPath = null;
            let debounceTimeout;

            function getTabURLFromPath(path) {
                // Define URL-to-tab mapping based on expected paths
                if (path.startsWith("/chapter")) return "chapters-tab";
                if (path === "/modules") return "modules-tab";
                if (path === "/books") return "books-tab";
                if (path.startsWith("/test")) return "tests-tab";
                return null;
            }

            function updateActiveTabFromURL() {
                const currentPath = window.location.pathname;

                // Avoid unnecessary updates
                if (lastPath !== null && currentPath === lastPath) {
                    return;
                }
                lastPath = currentPath;

                const tabBtns = document.querySelectorAll('[data-toggle="tab"]');
                tabBtns.forEach(tabBtn => tabBtn.classList.remove("active"));

                // Determine which tab should be active
                const activeTabID = getTabURLFromPath(currentPath);
                if (activeTabID) {
                    const activeTab = document.getElementById(activeTabID);
                    if (activeTab) activeTab.classList.add("active");
                }
                
                // Hide subject dropdown when "Tests" tab is active
                const subjectDropdown = document.getElementById("subject-dropdown");
                if (activeTabID === "tests-tab" && !currentPath.endsWith("/add-test")) {
                    subjectDropdown.style.display = "none";
                } else {
                    subjectDropdown.style.display = "inline-block";
                }
            }

            /*
             * function to minimize same multiple calls happening within 50ms 
             * due to multiple quick afterSettle events received 
             */
            function debounceUpdate() {
                clearTimeout(debounceTimeout);
                debounceTimeout = setTimeout(updateActiveTabFromURL, 100); // Delay execution slightly
            }

            document.body.addEventListener("htmx:afterSettle", debounceUpdate);
        });

        // Function to go back after delay
        function goBackAfterDelay(milliseconds) {
            var userNavigatedBack = false;  // Flag to track if the user pressed the back button

            // Listen for the browser's back button (popstate event)
            window.addEventListener('popstate', function (event) {
                userNavigatedBack = true;  // User manually pressed the back button
            }, { once: true });

            setTimeout(function () {
                if (!userNavigatedBack) {
                    history.back(); // Go back to the previous state
                }
            }, milliseconds);
        }

        htmx.defineExtension('mathJaxLoader', {
            onEvent: function (name, event) {
                /**
                 * window.MathJax condition is not required right now because it will always return non-null
                 * value for our case as we have included MathJax script in this home.html file which is 
                 * used as base template for all screens, but still it is recommended way to handle cases 
                 * where MathJax can not be loaded due to network or cdn issues OR in future if we create
                 * some pages not requiring MathJax and hence shift its script declaration from this file
                 * to files where it is required
                 */
                if (name === "htmx:afterSwap" && window.MathJax) {
                    let targetElement = event.detail.target;

                    // Check if the target element itself has data-mathjax
                    let hasMathJax = targetElement.hasAttribute("data-mathjax");

                    // Check if any nested elements have data-mathjax
                    if (!hasMathJax) {
                        hasMathJax = targetElement.querySelector('[data-mathjax]') !== null;
                    }

                    // Apply MathJax.typesetPromise() only if at least one element has data-mathjax
                    if (hasMathJax) {
                        MathJax.typesetPromise([targetElement]).catch(console.error);
                    }
                }
            }
        })
    </script>
</body>

</html>