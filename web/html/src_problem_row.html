{{ range . }}
<tr class="border-b">
    <td class="p-2">{{.Code}}</td>
    <td class="p-2">{{.MetaData.Question}}</td>
    <td class="p-2 text-center"><button class="px-2 py-1 bg-green-500 text-white rounded" data-id="{{.ID}}"
            data-code="{{.Code}}" data-question="{{.MetaData.Question}}" data-subject="{{.Subject.ID}}"
            data-subtype="{{.Subtype}}" data-difficulty="{{.DifficultyLevel}}"
            hx-on:click="addQuestionToTest(this)">+</button>
    </td>
</tr>

<script>
    function addQuestionToTest(btn) {
        const dataset = btn.dataset
        const subtype = dataset.subtype;
        const subjectId = dataset.subject;
        const difficulty = dataset.difficulty;
        const questionsTableBody = document.querySelector("#questions-table-body");

        const subjectRows = questionsTableBody.querySelectorAll(`tr[data-subject="subject-${subjectId}"]`);
        const subtypeRows = questionsTableBody.querySelectorAll(`tr[data-subject="subject-${subjectId}"][data-subtype="subtype-${subtype}"]`);
        const insertAfterId = getInsertAfterId(subjectRows, subtypeRows);

        // Hook a one-time global listener that just closes over this specific button's data
        const handler = createAfterRequestHandler(difficulty, insertAfterId, questionsTableBody);
        document.body.addEventListener("htmx:afterRequest", handler);

        htmx.ajax("POST", "/add-question-to-test", {
            target: btn.closest("tr"),
            swap: "delete",
            values: {
                "id": dataset.id,
                "code": dataset.code,
                "question": dataset.question,
                "subtype": subtype,
                "subject-id": subjectId,
                "difficulty": difficulty,
                "subject-exists": subjectRows.length > 0,
                "subtype-exists": subtypeRows.length > 0,
                "insert-after-id": insertAfterId
            }
        });
    }

    function getInsertAfterId(subjectRows, subtypeRows) {
        if (subtypeRows.length > 0) {
            // Subtype exists — insert after last row of this subtype
            return subtypeRows[subtypeRows.length - 1].id;
        }

        if (subjectRows.length > 0) {
            // Subtype doesn't exist but subject does — insert after last subject-related row
            return subjectRows[subjectRows.length - 1].id;
        }

        return "";
    }

    function createAfterRequestHandler(difficulty, insertAfterId, tableBody) {
        return function handler(event) {
            if (event.detail.successful) {
                incrementLevelCount(difficulty);
                updateSerialNumbers(insertAfterId, tableBody);
            }
            document.body.removeEventListener("htmx:afterRequest", handler);
        }
    }

    function incrementLevelCount(difficulty) {
        // Increase the count in the levels table
        const levelCell = document.getElementById(`level-${difficulty}`);
        if (levelCell) {
            levelCell.textContent = parseInt(levelCell.textContent) + 1;
        }
    }

    function updateSerialNumbers(insertAfterId, tableBody) {
        // Assign serial number to newly added row and Update serial numbers of all affected rows
        let serial = 0;
        let currentRow;

        if (insertAfterId !== "") {
            const insertAfterRow = document.getElementById(insertAfterId);
            const firstTd = insertAfterRow.querySelector("td");
            serial = parseInt(firstTd.textContent);
            currentRow = insertAfterRow.nextElementSibling;

        } else {
            // Inserted without known insertAfterId — find previous valid row with serial number
            const allRows = Array.from(tableBody.querySelectorAll("tr"));
            // loop in reverse order
            for (let i = allRows.length - 1; i >= 0; i--) {
                const row = allRows[i];
                const firstTd = row.querySelector("td");

                // find valid problem rows (excluding subject/problem type header rows)
                if (!firstTd.hasAttribute("colspan")) {

                    // last problem row added just now
                    if (firstTd.textContent.trim() === "") {
                        currentRow = row;

                    } else {
                        // serial number of 2nd last problem
                        serial = parseInt(firstTd.textContent.trim());
                        break;
                    }
                }
            }
        }

        // Update serial numbers, skipping colspan header rows
        while (currentRow) {
            const firstTd = currentRow.querySelector("td");
            if (!firstTd.hasAttribute("colspan")) {
                firstTd.textContent = ++serial;
            }
            currentRow = currentRow.nextElementSibling;
        }
    }
</script>
{{ end }}