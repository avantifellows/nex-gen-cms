<table class="min-w-full bg-white">
    <thead>
        <tr class="bg-gray-200 text-gray-600 text-sm">
            <th class="py-4 px-6 text-left">
                <a href="#" hx-get="/tests" hx-target="body" hx-on:click="updateTableSortState('1', 'tests');">
                    Code <i class="fas fa-sort"></i>
                </a>
            </th>
            <th class="px-6 text-left">
                <a href="#" hx-get="/tests" hx-target="body" hx-on:click="updateTableSortState('2', 'tests');">
                    Name <i class="fas fa-sort"></i>
                </a>
            </th>
            <th class="px-6 text-center">
                <a href="#" hx-get="/tests" hx-target="body" hx-on:click="updateTableSortState('3', 'tests');">
                    Curriculum <i class="fas fa-sort"></i>
                </a>
            </th>
            <th class="px-6 text-center">
                <a href="#" hx-get="/tests" hx-target="body" hx-on:click="updateTableSortState('4', 'tests');">
                    Grade <i class="fas fa-sort"></i>
                </a>
            </th>
            <th class="px-6 text-center">
                <a href="#" hx-get="/tests" hx-target="body" hx-on:click="updateTableSortState('5', 'tests');">
                    Test Type <i class="fas fa-sort"></i>
                </a>
            </th>
            <th class="px-6 text-center">Actions</th>
        </tr>
    </thead>
    <tbody id="test-table-body" class="text-gray-600 text-sm" hx-ext="infiniteScroll" hx-get="/api/tests?limit=10&offset=0"
        hx-trigger="load" hx-swap="beforeend" data-limit="10" data-offset="0" hx-include="#test-search">
        <!-- Rows will be dynamically inserted here -->
    </tbody>
</table>
<div id="loader" class="hidden flex justify-center py-4">
    <div class="w-6 h-6 border-4 border-gray-300 border-t-blue-600 rounded-full animate-spin"></div>
</div>
<script>
    htmx.defineExtension('infiniteScroll', {
        onEvent: function (name, evt) {
            // Show loader before any request (including first load)
            if (name === 'htmx:beforeRequest') {
                const el = evt.detail.elt;
                if (el.getAttribute("hx-ext")?.includes("infiniteScroll")) {
                    document.getElementById("loader").classList.remove("hidden");
                }
            }

            // when new content is swapped in
            if (name === 'htmx:afterSwap') {
                const target = evt.detail.target;
                if (target.getAttribute("hx-ext")?.includes("infiniteScroll")) {
                    document.getElementById("loader").classList.add("hidden");
                }

                const request = evt.detail.xhr.responseURL;
                const queryString = request.split("?")[1] || "";
                target.setAttribute("data-last-params", queryString);

                const limit = parseInt(target.getAttribute("data-limit") || "10", 10);
                const offset = parseInt(target.getAttribute("data-offset") || "0", 10);
                target.setAttribute("data-offset", offset + limit);
                target.removeAttribute("data-loading");

                // Check server flag if present
                const hasMore = evt.detail.xhr.getResponseHeader("hasMore");
                if (hasMore === "false") {
                    // Server indicates no more results, disabling sentinel.
                    if (target.__sentinel) {
                        target.__sentinel.remove();
                        target.__sentinel = null;
                    }
                    return;
                }

                // Create sentinel once
                if (!target.__sentinel) {
                    const sentinel = document.createElement("tr");
                    sentinel.className = "infinite-scroll-sentinel";
                    sentinel.style.height = "1px";
                    target.appendChild(sentinel);
                    target.__sentinel = sentinel;

                    const observer = new IntersectionObserver((entries) => {
                        entries.forEach(entry => {
                            if (entry.isIntersecting && target.getAttribute("data-loading") !== "true") {
                                target.setAttribute("data-loading", "true");
                                document.getElementById("loader").classList.remove("hidden");

                                let limit = target.getAttribute("data-limit") || "10";
                                let offset = target.getAttribute("data-offset") || "0";
                                let baseUrl = target.getAttribute("hx-get");
                                let params = new URLSearchParams(target.getAttribute("data-last-params") || "");
                                params.set("limit", limit);
                                params.set("offset", offset);

                                const [basePath] = baseUrl.split("?");
                                const finalUrl = `${basePath}?${params.toString()}`;

                                htmx.ajax("GET", finalUrl, {
                                    target: target,
                                    swap: "beforeend",
                                    afterSwap: () => {
                                        document.getElementById("loader").classList.add("hidden");
                                        target.removeAttribute("data-loading");
                                    },
                                    onError: () => {
                                        document.getElementById("loader").classList.add("hidden");
                                        target.removeAttribute("data-loading");
                                    }
                                });
                            }
                        });
                    }, {
                        root: null,
                        rootMargin: "100px",
                        threshold: 0
                    });

                    observer.observe(sentinel);

                    // MutationObserver to clean up when table is removed
                    const cleanupObserver = new MutationObserver(() => {
                        if (!document.contains(target)) {
                            observer.disconnect();
                            cleanupObserver.disconnect();
                        }
                    });
                    cleanupObserver.observe(document.body, { childList: true, subtree: true });

                } else {
                    // Sentinel already exists â€” ensure it stays last after swap
                    target.appendChild(target.__sentinel);
                }
            }
        }
    });
</script>